package com.example.lms.service;

import com.example.lms.domain.Administrator;
import com.example.lms.domain.ChatMessage;
import com.example.lms.domain.ChatSession;
import com.example.lms.repository.AdministratorRepository;
import com.example.lms.repository.ChatMessageRepository;
import com.example.lms.repository.ChatSessionRepository;
import com.example.lms.service.ChatHistoryService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

/**
 * Unified implementation of {@link ChatHistoryService} that merges the best parts
 * of the two previous versions:
 * <ul>
 *     <li>▸ Saves the <b>first user message</b> immediately after creating a session.</li>
 *     <li>▸ Provides a dedicated {@code appendMessage()} utility for single‑message insertions.</li>
 *     <li>▸ Lazily loads sessions but <b>eagerly attaches</b> their messages when requested.</li>
 *     <li>▸ Keeps convenience helpers for reading / deleting sessions, with rich logging.</li>
 * </ul>
 * <p>
 * All write methods are wrapped in {@code @Transactional} for atomicity, while read operations
 * use {@code @Transactional(readOnly = true)} for better performance.
 * </p>
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class ChatHistoryServiceImpl implements ChatHistoryService {

    private final ChatSessionRepository sessionRepository;
    private final ChatMessageRepository messageRepository;
    private final AdministratorRepository administratorRepository;


    /* -----------------------------------------------------------
     *  Simple guard: ignore HTML trace blobs generated by
     *  NaverSearchService.buildTraceHtml() so they don’t pollute
     *  chat_message.content.  Real solution is DTO separation,
     *  but this prevents DB-noise immediately.
     * ----------------------------------------------------------- */
    private static boolean looksLikeTrace(String c) {
        return c != null && (c.startsWith("?TRACE?") || c.contains("class=\"search-trace\""));
    }

    private void saveIfNotTrace(ChatMessage msg) {
        if (looksLikeTrace(msg.getContent())) {
            log.debug("TRACE HTML detected – skip persist (session {})",
                    msg.getSession().getId());
            return;
        }
        messageRepository.save(msg);
    }

    // ---------------------------------------------------------------------
    // Session life‑cycle
    // ---------------------------------------------------------------------

    /**
     * Creates a new chat session that belongs to the given administrator and persists the very first
     * user message at once so that downstream components can rely on a complete history.
     *
     * @param firstMessage initial message from the user that also becomes the session title.
     * @param username     administrator who owns the session (must exist).
     * @return newly created {@link ChatSession} wrapped in an {@link Optional}
     */
    //@PreAuthorize("hasRole('ADMIN')") // enable when you wire method‑level security
    @Override
    @Transactional
    public Optional<ChatSession> startNewSession(String firstMessage, String username) {
        Administrator admin = administratorRepository.findByUsername(username)
                .orElseThrow(() -> new IllegalArgumentException("관리자를 찾을 수 없습니다: " + username));

        String title = firstMessage.length() > 20 ? firstMessage.substring(0, 20) + "..." : firstMessage;

        ChatSession session = sessionRepository.save(new ChatSession(title, admin));
        log.info("{} 관리자가 세션을 시작했습니다. title='{}' (id={})", username, title, session.getId());

        // persist the initial user message so the history starts with it
        ChatMessage initMsg = new ChatMessage(session, "user", firstMessage);
        messageRepository.save(initMsg);
        log.debug("세션 {}: 첫 사용자 메시지 저장 완료", session.getId());

        return Optional.of(session);
    }

    // ---------------------------------------------------------------------
    // Message utilities
    // ---------------------------------------------------------------------

    /**
     * Appends both user & assistant messages to a session in one go.
     */
    @Override
    @Transactional
    public void addMessagesToSession(ChatSession session, String userMessage, String assistantMessage) {
        ChatMessage user      = new ChatMessage(session, "user",      userMessage);
        ChatMessage assistant = new ChatMessage(session, "assistant", assistantMessage);
        saveIfNotTrace(user);
        saveIfNotTrace(assistant);
        log.debug("세션 {}: 대화 페어 저장 완료", session.getId());
    }

    /**
     * Appends a single message (typically called by higher‑level service code after the LLM responds).
     *
     * @param sessionId target session
     * @param role      one of "user", "assistant", "system" ...etc.
     * @param content   raw text content
     */
    @Override
    @Transactional
    public void appendMessage(Long sessionId, String role, String content) {
        ChatSession session = sessionRepository.findById(sessionId)
                .orElseThrow(() -> new IllegalArgumentException("세션을 찾을 수 없습니다: " + sessionId));
        ChatMessage msg = new ChatMessage(session, role, content);
        saveIfNotTrace(msg);
        log.debug("세션 {}: {} 메시지 저장", sessionId, role);
    }

    // ---------------------------------------------------------------------
    // Query helpers
    // ---------------------------------------------------------------------

    /** 관리자 전용: 전체 세션을 최신순으로 가져옵니다. */
    //@PreAuthorize("hasRole('ADMIN')")
    @Override
    @Transactional(readOnly = true)
    public List<ChatSession> getAllSessionsForAdmin() {
        return sessionRepository.findAllByOrderByCreatedAtDesc();
    }

    /**
     * Returns every chat session owned by the given admin (newest first).
     */
    @Override
    @Transactional(readOnly = true)
    public List<ChatSession> getSessionsForUser(String username) {
        return sessionRepository.findByAdministrator_UsernameOrderByCreatedAtDesc(username);
    }

    /**
     * Loads a session and eagerly attaches its messages list so that callers receive a fully
     * populated conversation history without hitting a lazy‑loading trap later.
     */
    @Override
    @Transactional(readOnly = true)
    public ChatSession getSessionWithMessages(Long id) {
        ChatSession session = sessionRepository.findById(id)
                .orElseThrow(() -> new IllegalArgumentException("세션을 찾을 수 없습니다: " + id));
        // Force initialize messages (avoids LazyInitializationException outside TX)
        session.setMessages(messageRepository.findBySessionId(id));
        return session;
    }

    /** Deletes a session and cascades message removal via DB FK or JPA orphan rules. */
    @Override
    @Transactional
    public void deleteSession(Long id) {
        sessionRepository.deleteById(id);
        log.info("세션 {} 삭제 완료", id);
    }
}
